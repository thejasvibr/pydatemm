# -*- coding: utf-8 -*-
"""
Kreissig-Yang 2013 with irrelevant cFLs
=======================================
Build on `synthetic_data_generation` by including some irrelevant cFLs that 
don't correspond to a source.

By calculating the residual TDOA error,we see a 13 order of magnitude difference
in the 'actual' sources, vs the fake sources generated by simulating similar
array geoms and source positions. 

@author: theja
"""
from synthetic_data_generation import * 
from pydatemm.tdoa_quality import residual_tdoa_error

#%% Make the 'actual' sources from the 'actual' array
array_geom = pd.read_csv('../pydatemm/tests/scheuing-yang-2008_micpositions.csv').to_numpy()
#array_geom = array_geom[:,:]

nchannels = array_geom.shape[0]
sources = [np.array([1,2,3]), np.array([5,0.5,-2]), np.array([8,-2.5,10])]

def mic2source(sourcexyz, arraygeom):
    mic_source= distance_matrix(np.vstack((sourcexyz, arraygeom)),
                                 np.vstack((sourcexyz, arraygeom)))[1:,0]
    return mic_source

mic2sources = [mic2source(each, array_geom) for each in sources]    
delta_tdes = [np.zeros((nchannels, nchannels)) for each in range(len(mic2sources))]

for i,j in product(range(nchannels), range(nchannels)):
    for source_num, each in enumerate(delta_tdes):
        each[i,j] = mic2sources[source_num][i]-mic2sources[source_num][j] 
        each[i,j] /= vsound

#%% Now make the tde matrices for the erroneous sources generated by 
# made up array geometries
index_count = len(delta_tdes)
all_madeup = []
for k in range(index_count-1, index_count+6):
    madeup_geom = array_geom + np.random.normal(0,0.05,24).reshape(-1,3)
    madeup_coordinates = np.random.normal(0,5,3)
    all_madeup.append(madeup_coordinates)
    madeup_mic2sources = [mic2source(each, madeup_geom) for each in [madeup_coordinates]]
    madeup_tde_matrix = np.zeros((nchannels, nchannels))
    for i,j in product(range(nchannels), range(nchannels)):
        madeup_tde_matrix[i,j] = madeup_mic2sources[0][i] - madeup_mic2sources[0][j]
        madeup_tde_matrix[i,j] /= vsound
    delta_tdes.append(madeup_tde_matrix)

# Make the cfls now:
cfls_s12 = [make_all_fundaloops_from_tdemat(deltatde) for deltatde in delta_tdes]
print('Making CCG Matrix now...')
ccg_s12 = [make_ccg_matrix(cfls_s) for cfls_s in cfls_s12]
# qq1 = combine_all(ccg_s12[0], set(range(nchannels)), set([]), set([]))
# qq2 = combine_all(ccg_s12[1], set(range(nchannels)), set([]), set([]))
# And now let's combine the two cfls sets together and see how well it all
# works
cfls_combined = list(chain(*cfls_s12))
ccg_combined = make_ccg_matrix(cfls_combined)
print('Running CombineAll..')
qq_combined = combine_all(ccg_combined, set(range(len(ccg_combined))), set([]), set([]))    
comp_cfls = format_combineall(qq_combined)

#%%
unique_positions = []
for compat_cfls in comp_cfls:
    source_cfls = [cfls_combined[each] for each in compat_cfls]
    s1_composed = combine_compatible_triples(source_cfls)
    s1c_tde = nx.to_numpy_array(s1_composed, weight='tde')
    channels = list(s1_composed.nodes)
    localised_source = spiesberger_wahlberg_solution(array_geom[channels,:],s1c_tde[1:,0]*340)
    if not np.sum(np.isnan(localised_source))>0:
        print(localised_source)
        if list(localised_source) in unique_positions:
            pass
        else:
            unique_positions.append(list(localised_source))
            error = residual_tdoa_error(s1_composed, localised_source, array_geom[channels,:])
            print('TDOA error', error)